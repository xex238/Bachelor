#include <algorithm>
#include <iostream>
#include <vector>
#include <cstdio>
using namespace std;

struct edge
{
	int x, y;
	edge() = default;
	edge(int x, int y);
};

edge::edge(int x, int y)
{
	this->x = x;
	this->y = y;
}

int main()
{
	int m, n; // m - рёбра, n - множество вершин
	cin >> m >> n;
	cout << endl;

	vector<edge> graph(m); // Рёбра исходного графа
	vector<edge> three; // Рёбра нового дерева
	vector<int> variety(n); // Множество вершин

	for (int i = 0; i < n; i++) // Определяем для каждой вершины своё множество
	{
		variety[i] = i;
	}

	int a{ 0 };
	int b{ 0 };
	for (int i = 0; i < m; i++) // Заполняем рёбра исходного графа
	{
		cin >> a >> b;
		cout << endl;
		graph[i].x = a;
		graph[i].y = b;
	}

	// Проверяем вершины каждого ребра. Если вершины не принадлежат одному и тому же множеству,
	// то такое ребро добавляем в наше дерево, а вершины помещаем в одно множество
	int old_variety{ 0 };
	int new_variety{ 0 };
	for (int i = 0; i < m; i++)
	{
		a = graph[i].x;
		b = graph[i].y;
		if (variety[a] != variety[b])
		{
			three.push_back(graph[i]);
			old_variety = variety[b];
			new_variety = variety[a];
			for (int j = 0; j < n; j++)
			{
				if (variety[j] == old_variety)
				{
					variety[j] = new_variety;
				}
			}
		}
	}

	cout << "Old tree" << endl;
	for (int i = 0; i < m; i++)
	{
		cout /*<< i */<< " " << graph[i].x << " " << graph[i].y << endl;
	}
	cout << "New tree" << endl;
	for (int i = 0; i < three.size(); i++)
	{
		cout /*<< i */<< " " << three[i].x << " " << three[i].y << endl;
	}
	cout << endl;
}
